/**
 * Code for running Logistic Regression results.
 *
 * TODO Documentation in progress
 * TODO There needs to be a better way to input the data than what we have now.
 * TODO don't forget to adjust model parameters in case we change 'n'.
 */

// TODO Have my data directories here (but again, this has to be in a better spot).
val train_data_dir = "/home/seita/BIDMach/data/MNIST8M_daniel/FINAL_MNIST8M_TRAIN_10000.fmat.lz4"
val test_data_dir = "/home/seita/BIDMach/data/MNIST8M_daniel/FINAL_MNIST8M_TEST_10000.fmat.lz4"


:load simulator.ssc
:load cutMHTest.ssc
:load adaptiveMHTest.ssc

class LogisticRegression(n:Int, sigma:Double, pscale: Double) extends MHmodel (1, n, sigma, pscale) {
	
    var sigma_proposer = 0.05;
    var temp = 1.0;
    // val data:DMat = load("minist7vs1.mat","Train");
    val data = loadFMat(train_data_dir)
   
    def initfn():Mat = {
        val parameter_dim = data.dims(0) - 1;
        val theta = drand(parameter_dim,1);
        theta;
    };
    
    def proposalfn(theta:Mat):Mat = {
        theta + dnormrnd(0, sigma_proposer, theta.dims(0), 1);
    };
    
    def evalfn(batch:Mat, theta:Mat):Mat = {
        val X = batch(0 until batch.dims(0)-1, ?)
        val Y = batch(batch.dims(0)-1,?)
        val z = Y dot (theta.t * X);
        val sig = 1/(1 + exp(-1.0 * z));
        val log_sig = ln(sig);
        val scale_and_temp = 1.0 * (n/temp);
        scale_and_temp * log_sig;
    };
}
	
def eval_cost(X:DMat, Y:DMat, theta:DMat): (DMat, DMat) = {
	val z = Y *@ (theta.t * X);
	val sig = 1.0/ (1.0 + exp(-1.0 * z));
	var accuracy = dzeros(sig.dims(0),1);
	var ll = dzeros(sig.dims(0),1);
	for(i<- 0 until sig.dims(0)){
		val temp = sig(i, ?);
		accuracy(i) = find(temp>0.5).dims(0) * 1.0 / temp.dims(1) * 1.0;
		ll(i) = sum(ln(temp)).dv * 1.0 / temp.dims(1) * 1.0;
	}
	return (accuracy, ll);
};


// define model parameters
val nsamps = 5000 // Daniel: this should be 5000 but I may change if I'm experimenting.
val n = 10000 // Daniel, October 7 2016: this previously was 12007.
val sigma = 1.0
val pscale = 1.0
val batchsize = 100
val sigma_proposer = 0.05;
val nn = new LogisticRegression(n=n, sigma=sigma, pscale=pscale);
nn.temp = 1000.0; // Was 1000.0 for the original 12k dataset.
nn.sigma_proposer = sigma_proposer;

// define test parameters
val newtest = new NewTest;
newtest.explin = false;
val oldtest = new OldTest;
oldtest.explin = false;
val cutMHtest = new cutMHTest;
val adaptiveMHtest = new adaptiveMHTest;
cutMHtest.N = n;
adaptiveMHtest.N = n;
cutMHtest.eps = 0.005;


// ---------------------------------------- //
// ----- TEST #1: OUR METHOD ("ours") ----- //
// ---------------------------------------- //
tic;
val (samples_ours, mb_size_ours, ll_train_ours) = dosimm(mod=nn, test=newtest, size=batchsize, nsamps=nsamps, acc=0.05);
val t1 = toc;

// ----------------------------------------- //
// ----- TEST #2: KORATTIKARA ("kora") ----- //
// ----------------------------------------- //
val (samples_kora, mb_size_kora, ll_train_kora) = cutMHTest_dosimm(mod=nn, test=cutMHtest, size=batchsize, nsamps=nsamps, acc=0.05);
val t2 = toc - t1;

// -------------------------------------- //
// ----- TEST #3: BARDENET ("bard") ----- //
// -------------------------------------- //
val (samples_bard, mb_size_bard, ll_train_bard, bc1c2_list) = adaptiveMH_dosimm(mod=nn, test=adaptiveMHtest, size=batchsize, nsamps=nsamps, acc=0.05);
val t3 = toc - t2;


// val testdata:DMat = load("minist7vs1.mat","Test");
val testdata = loadFMat(test_data_dir)
val X = testdata(0 until testdata.dims(0)-1, ?)
val Y = testdata(testdata.dims(0)-1, ?)

val (accuracy_ours, ll_test_ours) = eval_cost(X, Y, samples_ours);
val (accuracy_kora, ll_test_kora) = eval_cost(X, Y, samples_kora);
val (accuracy_bard, ll_test_bard) = eval_cost(X, Y, samples_bard);

val cum_size_ours = cumsum(DMat(mb_size_ours));
val cum_size_kora = cumsum(DMat(mb_size_kora));
val cum_size_bard = cumsum(DMat(mb_size_bard));

// Might be useful later.
val times = t1 \ t2 \ t3
print(times)

saveAs("logisticdata.mat", samples_ours, "samples_ours", 
                           samples_kora, "samples_kora",
                           samples_bard, "samples_bard",
                           cum_size_ours, "cum_size_ours",
                           cum_size_kora, "cum_size_kora", 
                           cum_size_bard, "cum_size_bard", 
                           ll_train_ours, "ll_train_ours", 
                           ll_train_kora, "ll_train_kora", 
                           ll_train_bard, "ll_train_bard", 
                           ll_test_ours, "ll_test_ours", 
                           ll_test_kora, "ll_test_kora", 
                           ll_test_bard, "ll_test_bard", 
                           accuracy_ours, "accuracy_ours", 
                           accuracy_kora, "accuracy_kora", 
                           accuracy_bard, "accuracy_bard");
