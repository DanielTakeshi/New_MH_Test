:load simulator.ssc

class GaussianMixture(n:Int, sigma:Double, pscale:Double) extends MHmodel(2, n, sigma, pscale) {

	val sigma1_sq = 10.0;	
	val sigma2_sq = 1.0;
	var sigma_proposer = 0.5;
	val theta1 = 0.0;
	val theta2 = 1.0;
	val u = rand(1,n);
	val data = dzeros(1,n);
	var temp = 1.0;

	def initfn():Mat = {
		// Data Generation
		for(i <- 0 until n){
			if (u(i) < 0.5){
				data(i) = dnormrnd(theta1, sigma.toFloat,1,1)(0)
			}
			else{
				data(i) = dnormrnd(theta1+theta2, sigma.toFloat,1,1)(0)
			}
		};
		
		// Initialize parameters
		val res = dones(2,1);
		res(0) = 0.5;
		res(1) = 0.0;
		res;
	};

	def proposalfn(theta:Mat):Mat ={
		theta +  dnormrnd(0, sigma_proposer, 2, 1);
	};

	def evalfn(batch:Mat, theta:Mat) : Mat = {
		val dd1 = batch - theta(0);
		val dd2 = batch - theta(0) - theta(1);
		val scale_and_temp = 1.0 * (n/temp);
		val log_term = ln( exp( -0.5 / (sigma * sigma) * ( dd1 dot dd1) ) + exp( -0.5 / (sigma * sigma) * (dd2 dot dd2) ) );
		scale_and_temp * log_term;
	};

};


def acceptrate(theta:Mat):Double = {
	val diff = abs(theta(?,1->(theta.ncols)) - theta(?,0->(theta.ncols-1)));
	return mean(sum(diff)>0.0).dv;
};		

val nsamps = 2000
val n = 100000
val sigma = math.sqrt(2)
val pscale = 1
val batchsize = 200
val sigma_proposer = 0.5;
val nn = new GaussianMixture(n = n, sigma = sigma, pscale=pscale);

nn.temp = nn.n/100.0;
nn.sigma_proposer = sigma_proposer;   // 0.4 is optimal for nsamps = 2000, minibatch size = 200	
val newtest = new NewTest;
val oldtest = new OldTest;

tic; 
val (samples, sizes, lls) = dosimm(mod=nn, test=newtest, size=batchsize, nsamps=nsamps, acc = 0.05);
val t1 = toc;

val (samples2, sizes2, lls2) = dosimm(mod=nn, test=oldtest, size=batchsize, nsamps=nsamps, acc = 0.05);
val t2 = toc - t1;

// plot result of new test
val a = samples(?,(nsamps/2)->nsamps);
scatter(a(0,?),a(1,?));
val size1 = FMat(sizes)	
hist(size1,50);
val theta = samples
val accept = acceptrate(theta);
val progress = accept * sigma_proposer * sigma_proposer;
print(accept); 
print("  ");
print(sigma_proposer); 
print("  ");
println(progress);



// plot result of old test
val b = samples2(?,(nsamps/2)->nsamps);
scatter(b(0,?),b(1,?));
val size2 = FMat(sizes2)
hist(size2,50);
val theta2 = samples2
val accept2 = acceptrate(theta2);
val progress2 = accept2 * sigma_proposer * sigma_proposer;
print(accept2); 
print("  ");
print(sigma_proposer); 
print("  ");
println(progress2);
	
val accelerate = sum(size2)/sum(size1);		
println("accelerate ratio is %f" format(accelerate.dv));
