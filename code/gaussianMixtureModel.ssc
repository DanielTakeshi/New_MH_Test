// This script runs our MH test and standard MH test on Gaussian Mixture Model
// :silent
:load simulator.ssc
:load cutMHTest.ssc
:load adaptiveMHTest.ssc

class GaussianMixture(n:Int, sigma:Double, pscale:Double) extends MHmodel(2, n, sigma, pscale) {

	val sigma1_sq = 10.0;	
	val sigma2_sq = 1.0;
	var sigma_proposer = 0.5;
	val theta1 = 0.0;
	val theta2 = 1.0;
	val u = rand(1,n);
	val data = dzeros(1,n);
	var temp = 1.0;

	def initfn():Mat = {
		// Data Generation
		for(i <- 0 until n){
			if (u(i) < 0.5){
				data(i) = dnormrnd(theta1, sigma.toFloat,1,1)(0)
			}
			else{
				data(i) = dnormrnd(theta1+theta2, sigma.toFloat,1,1)(0)
			}
		};
		
		// Initialize parameters
		val res = dones(2,1);
		res(0) = 0.5;
		res(1) = 0.0;
		res;
	};

	def proposalfn(theta:Mat):Mat ={
		theta +  dnormrnd(0, sigma_proposer, 2, 1);
	};

	def evalfn(batch:Mat, theta:Mat) : Mat = {
		val dd1 = batch - theta(0);
		val dd2 = batch - theta(0) - theta(1);
		val scale_and_temp = 1.0 * (n/temp);
		val log_term = ln( exp( -0.5 / (sigma * sigma) * ( dd1 dot dd1) ) + exp( -0.5 / (sigma * sigma) * (dd2 dot dd2) ) );
		scale_and_temp * log_term;
	};

};


def acceptrate(theta:Mat):Double = {
	val diff = abs(theta(?,1->(theta.ncols)) - theta(?,0->(theta.ncols-1)));
	return mean(sum(diff)>0.0).dv;
};		



val nsamps = 5000
val n = 1000000
val sigma = math.sqrt(2)
val pscale = 1.0
val batchsize = 100
val sigma_proposer = 0.3;
val nn = new GaussianMixture(n = n, sigma = sigma, pscale=pscale);

nn.temp = nn.n/100.0;
nn.sigma_proposer = sigma_proposer;   
val newtest = new NewTest;
newtest.explin = false;
val oldtest = new OldTest;
oldtest.explin = true;
val cutMHtest = new cutMHTest;
val adaptiveMHtest = new adaptiveMHTest;
adaptiveMHtest.N = n;
cutMHtest.N = n;
cutMHtest.eps = 0.005;


tic; 
println("Doing Out Test");
val (samples, sizes, lls) = dosimm(mod=nn, test=newtest, size=batchsize, nsamps=nsamps, acc = 0.05);
val t1 = toc;
println("Finished Out Test");

println("Doing Old Test");
val (samples2, sizes2, lls2) = dosimm(mod=nn, test=oldtest, size=batchsize, nsamps=nsamps, acc = 0.05);
val t2 = toc - t1;
println("Finished Old Test");

println("Doing cut mh test");
val (samples3, sizes3, lls3) = cutMHTest_dosimm(mod=nn, test=cutMHtest, size=batchsize, nsamps=nsamps, acc=0.05);
println("Finished cut mh test");

val t3 = toc - t1 - t2;

println("Doing adaptive (bardenet's ) test")
val (samples4, sizes4, lls4, bc1c2_list) = adaptiveMH_dosimm(mod=nn, test=adaptiveMHtest, size=batchsize, nsamps = nsamps, acc=0.05);
println("Finished adaptive (bardenet's) test")

val t4 = toc - t1 - t2 - t3;

println("Doing cut mh test with decreasing error bound")
cutMHtest.error_bound = false; // test with decreasing error bound
val (samples5, sizes5, lls5) = cutMHTest_dosimm(mod=nn, test = cutMHtest, size=batchsize, nsamps = nsamps, acc = 0.05);
println("Finished cut mh test with decreasing error bound")

val t5 = toc - t1 - t2 - t3 - t4;



// plot result of new test
val a = samples(?,(nsamps/2)->nsamps);
// scatter(a(0,?),a(1,?));
val size1 = FMat(sizes)	
// hist(size1,50);


// plot result of old test

val b = samples2(?,(nsamps/2)->nsamps);
// scatter(b(0,?),b(1,?));
val size2 = FMat(sizes2)
// hist(size2,50);





// plot the result of cut mh test
val c = samples3(?, (nsamps/2)->nsamps);
// scatter(c(0,?), c(1,?));
val size3 = FMat(sizes3);
// hist(size3, 50);


// plot the result of adaptive mh test
val d = samples4(?, (nsamps/2)->nsamps);
// scatter(d(0,?), d(1,?))
val size4 = FMat(sizes4);
// hist(size4, 50);



// plot the result of cut mh test with decreasing error bound
val e = samples5(?, (nsamps/2)->nsamps);
// scatter(e(0,?), e(1,?))
val size5 = FMat(sizes5);
// hist(size5, 50);


// calculate acceleration ratio
// val accelerate = sum(size2).dv/sum(size1).dv;		
// println("accelerate ratio over old test is %f" format(accelerate));
val accelerate2 = sum(size3).dv/sum(size1).dv;
println("accelerate ratio over cutmh test is %f" format(accelerate2));
// val accelerate3 = sum(size4).dv/sum(size1).dv;
// println("accelerate ratio over adaptive mh test is %f" format(accelerate3));
val accelerate4 = sum(size5).dv/sum(size1).dv;
println("accelerate ratio over cut mh test with decreasing error bound is %f" format(accelerate4));

// save files
println("Saving results to gaussiandata.mat");
val time_list = t1 \ t2 \ t3 \ t4 \ t5;
saveAs("gaussiandata.mat", samples, "newtestsamples", samples2, "oldtestsamples",  samples3, "cutmhsamples", samples4, "adaptivemhsamples", samples5, "cutmhwithsamples", size1, "newtestsize", size2, "oldtestsize", size3, "cutmhsize", size4, "adaptivemhsize", size5, "cutmhwithsize", lls, "newtestll", lls2, "oldtestll", lls3, "cutmhll", lls4, "adaptivemhll", lls5, "cutmhwithll", bc1c2_list, "adaptivemhbc1c2", time_list, "time_list");
