// This script implements the Bardenet's 2014 ICML Paper

def std(A:DMat):Double = {
    (mean(A *@ A) - mean(A) * mean(A)).dv
}

class adaptiveMHTest {
	var N = 100000;     // Daniel: this gets overriden by our other scripts but we should improve design later
	var p = 2.0;
	var delta = 0.01;
	var gamma = 2.00;   // Daniel: important tuning parameter. We had 1.5, the paper used 2.0.
	def testfn(diff_in:Mat, psi: Double, b: Double, c :Double) : (Boolean, Boolean) = {
		// diff is the overall Lambda value without average
		var diff = diff_in / (N * 1.0);
		val diff_mean = mean(diff).dv;
		val test_stats = abs(diff_mean - psi).dv;
		if ((test_stats >= c) ||(b >= N)){
			if( diff_mean > psi ) {
				return (true, true)
			} else {
				return (true, false)
			}
		} else {
				return (false, false)
		}
	};
};

def getbatch(data:Mat, here:Int, size:Int):Mat = {
    val there = here + size;
    val nthere = math.min(there, data.ncols);
    val iwrap = math.max(0, there - data.ncols);
    val batch0 = data.colslice(here, nthere, null);
    val batch = if (iwrap > 0) {
		batch0 \ data.colslice(0, iwrap, null);
    } else {
		batch0;
    }
    batch;
};    


/**
 * Daniel: at some point we should document this because it's hard for me to quickly get up to speed
 * on what these methods mean by reading this.
 */
def adaptiveMH_dostep(mod:MHmodel, test:adaptiveMHTest, data:Mat, size:Int, here:Int, theta:Mat, ttheta:Mat, acc:Double):(Int, Mat, Double, Mat) = {
    var step = size;
    var done = false;
    var ntheta:Mat = null;
    var there = 0;
    var istep = 0;
    var ll:Mat = null;
    var bc1c2:Mat = 0.0 on 0.0 on 0.0;

    var b = size;
    var t = 0.0 ;
    var t_look = 1.0;
    test.N = data.ncols;
    val psi = 1.0/test.N * ln(rand(1,1)).dv;

    println("inside adaptiveMH_dostep, size=" +size+ ", now starting while loop...")
    while(!done) {
    	val temp_step = b.toInt;
    	step = temp_step;
        println("calling getbatch with step="+step)
    	val batch = getbatch(mod.data, here, step);
    	ll = mod.evalfn(batch, theta);
    	val diff = mod.evalfn(batch, ttheta) - ll;
    	t = b.toDouble;
    	t_look = t_look + 1.0;

    	val ctt_pre2 = (mod.evalfn(data, ttheta) - mod.evalfn(data, theta))*1.0/test.N;
    	val ctt_pre = abs(ctt_pre2);
    	val sigma_t = std(DMat(ctt_pre2));
    	val ctt = maxi(ctt_pre).dv;
    	val ft = (t - 1.0)/test.N * 1.0;
    	val delta_tlook = (test.p - 1.0)/(test.p * pow(t_look, test.p).dv) * test.delta * 1.0;
        val c1 = sigma_t * math.sqrt( 2 * ln(3.0/delta_tlook).dv / t);
        val c2 = 6.0 * ctt * ln(3.0/delta_tlook).dv / t;
    	val c = c1 + c2;

        bc1c2 = bc1c2 \ (b on c1 on c2);
    	b = min(test.N, ceil(test.gamma*t*1.0).v.toInt).v;
    	val (moved, takestep) = test.testfn(diff, psi, b, c);
    	done = moved;

    	if (done) {
	    	there = (here + step) % data.ncols;
	    	ntheta = if (takestep) ttheta else theta;
		}
		istep += 1;
   	}
    println("finished with adaptiveMH_dostep, \'there\'="+there+".")
    (there, ntheta, mean(ll).dv/(test.N * 1.0), bc1c2);
};


def adaptiveMH_dosimm(mod:MHmodel, test:adaptiveMHTest, size:Int, nsamps:Int, acc:Double):(DMat,LMat,DMat,DMat) = {
    var theta = mod.initfn();
    val samples = dzeros(theta.length, nsamps);
    val sizes = lzeros(1, nsamps);
    val lls = dzeros(1, nsamps);
    var here = 0;
    var i = 0;
    var bc1c2_list:Mat = 0.0 on 0.0 on 0.0;

    tic;
    println("")
    while (i < nsamps) {
    	if (i % 1 == 0){
            val t = toc
    		println("adaptive mh test iteration = %d, elapsed time = %f secs" format(i, t));
    	}
		val ttheta = mod.proposalfn(theta);
		val (there, nth, ll, bc1c2) = adaptiveMH_dostep(mod, test, mod.data, size, here, theta, ttheta, acc);
        bc1c2_list = bc1c2_list \ bc1c2;
		sizes(i) = if (there > here) (there - here) else (there - here + mod.data.ncols);
		lls(i) = ll;
		here = there;
		theta = nth;
		samples(?, i) = DMat(theta);
		i += 1;
    }
    println("")
    (samples, sizes, lls, DMat(bc1c2_list));
};


/*
val nsamps = 2000
val n = 100000
val sigma = math.sqrt(2)
val pscale = 1
val batchsize = 100
val sigma_proposer = 0.9;
val nn = new GaussianMixture(n = n, sigma = sigma, pscale=pscale);


nn.temp = 1000.0;
nn.sigma_proposer = sigma_proposer;   
val newtest2 = new adaptiveMHTest;
newtest2.N = n;

tic; 
val (samples, sizes, lls) = adaptiveMH_dosimm(mod= nn, test=newtest2, size=batchsize, nsamps = nsamps, acc = 0.05);
toc;

val t1 = toc;

scatter(samples(0,?), samples(1,?));
val size1 = FMat(sizes)
hist(size1);
*/

//val accept = acceptrate(samples)
//println("accept rate is %f" format(accept));
